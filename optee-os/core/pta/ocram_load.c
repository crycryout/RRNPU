// SPDX-License-Identifier: BSD-2-Clause
/*
 * Copyright (c) 2016, Linaro Limited
 * Copyright (c) 2022, Arm Limited and Contributors. All rights reserved.
 *
 * This pseudo-TA loads data from a supplied buffer (previously read from
 * secure storage) into a fixed physical address in OCRAM (0x20484050),
 * but before that clears the byte at physical address 0x20490000.
 */

 #include <compiler.h>
 #include <kernel/pseudo_ta.h>
 #include <malloc.h>
 #include <mm/tee_mm.h>
 #include <mm/tee_pager.h>
 #include <mm/core_memprot.h>
 #include <stdio.h>
 #include <string.h>
 #include <string_ext.h>
 #include <trace.h>
 #include <tee_api_types.h>
 #include <kernel/cache_helpers.h>
 
 #define TA_NAME       "ocram_load.pta"
 
 /* UUID generated by linux uuidgen */
 #define OCRAM_LOAD_UUID \
     { 0xd9e00de1, 0x950b, 0x4eb8, \
       { 0xb7, 0xd1, 0x6b, 0x32, 0xde, 0xec, 0x18, 0x57 } }
 
 /* Command ID */
 #define OCRAM_LOAD_CMD  0
 
 /*
  * pta_load_to_ocram - Load data from input buffer into OCRAM and clean cache,
  *                     but first clear one byte at physical 0x20490000.
  */
 static TEE_Result pta_load_to_ocram(uint32_t ptypes,
                                     TEE_Param params[TEE_NUM_PARAMS])
 {
     paddr_t flag_pa = 0x20490000;
     paddr_t dest_pa = 0x20484050;
     void *flag_va = NULL;
     void *dest_va = NULL;
     uint32_t size = params[0].memref.size;
     uint32_t i;
     const uint32_t dump_len = 1552;
     uint8_t *p;
 
     DMSG("pta_load_to_ocram called with ptypes=0x%" PRIx32, ptypes);
 
     /* 参数检查 */
     if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_INPUT,
                         TEE_PARAM_TYPE_NONE,
                         TEE_PARAM_TYPE_NONE,
                         TEE_PARAM_TYPE_NONE) != ptypes) {
         EMSG("Invalid parameter types, expected MEMREF_INPUT");
         return TEE_ERROR_BAD_PARAMETERS;
     }
 
     /* 大小检查 */
     if (size > 640 * 1024) {
         EMSG("Data size %u exceeds limit", size);
         return TEE_ERROR_BAD_PARAMETERS;
     }
 
     /* 1) 先映射并清零 0x20490000 处的一个字节 */
     flag_va = phys_to_virt(flag_pa, MEM_AREA_RAM_SEC, 1);
     if (!flag_va) {
         EMSG("Failed to map flag PA 0x%" PRIxPA, flag_pa);
         return TEE_ERROR_GENERIC;
     }
     /* 写 0 并清 Cache */
     *(uint8_t *)flag_va = 0;
     dcache_clean_range(flag_va, 1);
     DMSG("Cleared byte at PA 0x%" PRIxPA, flag_pa);
 
     /* 2) 再映射 OCRAM 目标区 */
     dest_va = phys_to_virt(dest_pa, MEM_AREA_RAM_SEC, 640 * 1024);
     if (!dest_va) {
         EMSG("Failed to map OCRAM PA 0x%" PRIxPA, dest_pa);
         return TEE_ERROR_GENERIC;
     }
     DMSG("Destination OCRAM PA mapped to VA 0x%" PRIxVA, (uintptr_t)dest_va);
 
     /* 3) 拷贝数据到 OCRAM */
     memcpy(dest_va, params[0].memref.buffer, size);
     DMSG("Copied %u bytes to OCRAM VA 0x%" PRIxVA, size, (uintptr_t)dest_va);
 
     /* 4) 清理 D-Cache */
     dcache_clean_range(dest_va, size);
     DMSG("Cleaned D-Cache for OCRAM VA 0x%" PRIxVA " size %u",
          (uintptr_t)dest_va, size);
     /* 5) Dump 1552 字节用于验证 */
 /*
     p = (uint8_t *)dest_va;
     DMSG("OCRAM verification dump (%u bytes):", dump_len);
     for (i = 0; i < dump_len; i++) {
         if ((i & 0x0F) == 0)
             DMSG("\n  ");
         DMSG("%02x ", p[i]);
     }
     DMSG("\nEnd of OCRAM dump\n");*/
 
     return TEE_SUCCESS;
 }
 
 /*
  * invoke_command - PTA命令分发
  */
 static TEE_Result invoke_command(void *psess __unused,
                                  uint32_t cmd,
                                  uint32_t ptypes,
                                  TEE_Param params[TEE_NUM_PARAMS])
 {
     if (cmd == OCRAM_LOAD_CMD)
         return pta_load_to_ocram(ptypes, params);
     return TEE_ERROR_BAD_PARAMETERS;
 }
 
 /* 注册 PTA */
 pseudo_ta_register(
     .uuid = OCRAM_LOAD_UUID,
     .name = TA_NAME,
     .flags = PTA_DEFAULT_FLAGS,
     .invoke_command_entry_point = invoke_command
 );
 